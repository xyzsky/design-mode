# 设计模式

组合思维、分层思维、工程思维、对象思维、迭代思维



软件开发过程 = 定义与分析 + 设计 + 实现 + 测试 + 交付 + 维护

软件工程 = 过程 + 工具 + 方法 （保证软件交付的效率和可靠性）

编程 = 写代码 + 讨论 + 学习 + 反思

高效编程 = 原则 * 工具 * 编码 * 反馈 * 迭代 （尝试去搭建新组件的实验环境、搭建自己的工具代码库）

**面向对象的优势：**

1. 模块化更适合团队敏捷开发
2. 对象结构更能提升代码重用性、可读性
3. 组合和聚合思想让代码演进更重视组件化



## 2 设计原则

### 2.1 单一原则 （DRY）

**定义 ：** 系统中的每一个功能都应该有唯一的实现，如果多次遇到同样的问题，就应该 抽象出一个共同的解决方法，而不要重复开发同样的功能代码。

陷阱1 ： 随时关注可重用性

陷阱2 ： 过渡设计   （抓住上下文，避免过度设计）

陷阱3：写一次代码 



### 2.2 简单原则 （KISS）

Keep It Simple and Stupid

**定义：** 指代码应该更容易理解、更容易编写、更容易改变，并应该一直保持如此。



>  保持简单并不是只能做简单设计或简单编程，而是做设计或编程时要努力以最终产出简单为目标，过程可能非常复杂也没关系。

**简单性始终是一个最终的结果，为了达到这个结果，过程可能会非常复杂！**

### 2.3 最少原则 （LoD）

迪米特法则（Low of Demeter）

**定义：** 1. 一个类只应该与它直接相关的类通信； 2. 每一个类应该知道自己需要的最少知识。

定义：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某个方法的话，可通过第三者转发这个调用。（来自大话设计模式）

在面向对象编程中，它要求任何一个对象（O）的方法 （m）， 只应该调用以下对象：

- 对象（O）自身
- 通过方法（m）的参数传入的对象
- 在方法（m）内创建的对象；
- 组成对象（O）的对象；
- 在方法（m）的范围内，可让对象（O）访问的全局变量。

**分层架构，其实就可以被认为是迪米特法则在架构设计上的一种具体体现**



### 2.4 表达原则 

（Program Intently and Expressively  , PIE）

**定义：** 指编程时应该有清晰的编程意图，并通过代码明确地表达出来。

快速提升代码可读性

- 易于维护
- 易于重构
- 易于测试
- 易于使用设计模式

想写出可读性高的代码，你可以从三个方面来入手。

- 代码表现形式：在命名（变量名、方法名、类名）、代码格式、注释等方面的改进。

- 控制流和逻辑：尽量分离控制流和逻辑，让代码变得更容易理解。 If-else

- 惯性思维：找出常犯的一些惯性思考方式并逐一改进。

### 2.5 职责分离

**定义：** 将不同变化原因引起的类或方法修改行为拆分到不同类或方法里去。



**职责分离的重要性**：

- 直接对问题进行对象建模，方便理清构建逻辑
- 将问题分解为各种职责，更有利于系统的测试，调试和维护
- 提高系统的可扩展性

> 只有有意识地进行职责分离才能提高代码的可维护性



### 2.6 面向对象原则 (SOLID 原则)



“SOILD”是由五大原则的英文首字母拼写而成，具体对应情况如下。

- S（Single Responsibility Principle，简称 SRP）：单一职责原则，意思是对象应该仅具有一种单一的功能。

- O（Open–Closed Principle，简称 OCP）：开闭原则，也就是程序对于扩展开放，对于修改封闭。

- L（Liskov Substitution Principle，简称 LSP）：里氏替换原则，程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的。
- I（Interface Segregation Principle，简称 ISP）：接口隔离原则，多个特定客户端接口要好于一个宽泛用途的接口。
- D（Dependency Inversion Principle，简称 DIP）：依赖反转原则，该原则认为一个方法应该遵从“依赖于抽象而不是一个实例”。

### 2.7 反转原则

依赖反转原则（Dependence Inversion Principle，简称 DIP）

**依赖反转原则（DIP）就是一种统一代码交互标准的软件设计方法。**

- IoC 容器是一种技术框架，它用来管理对象的创建及其生命周期，提供依赖注入实现，是 DI 的具体实现；
- DI 是一种设计模式，将依赖通过“注入”的方式提供给需要的类，是 DIP 和 IoC 的具体实现；
- IoC 是一种设计原则（或设计模式），将代码本职之外的工作交由某个第三方（框架）完成，与 DIP 相似；
- DIP 是一种设计原则，它认为高层组件的功能不应该依赖下层组件的实现，而应该提供抽象层让下层依赖，与 IoC 有异曲同工之妙。

DIP 是一种**设计理念**，是为了帮助我们解耦复杂的程序。换句话说，DIP 是一种简单但功能强大的设计思想，我们可以使用它来实现**结构良好、高度分离和可重用的软件组件**。

DIP 给我们带来一个重要启示：**不管是程序设计还是工作生活，如果依赖和控制的东西过多了，就要学会制定标准，倒置依赖，反转控制，释放自身资源，专注于更重要的事。**

### 2.6 惯例原则

**惯例原则就是将一些在编程中公认的配置方式和约定信息作为内部缺省的默认规则来使用**



### 2.8 分离原则

先将复杂问题做合理的分解，再分别仔细研究程序上特定问题的侧面（关注点），最后解决得出的接口，再合成整体的解决思路。

### 2.9 契约原则

契约式设计原则（Design by Contract，缩写为 DbC，为表述统一，下文我们就简称为“契约原则”），是一种软件设计方法。其原理是：在软件设计时应该为软件组件定义一种精确和可验证的接口规范，这种规范要包括使用的预置条件、后置条件和不变条件，用来扩展普通抽象数据类型的定义。

**就是当一个操作多次执行所产生的影响均与一次执行的影响相同，则它是幂等的。**

如何在 API 设计中做到接口幂等呢？通常有以下五种方法。

- 使用天然幂等的操作。比如，数据库中的 select 查询，只要数据没发生改变，那么查询一次和多次的结果始终是一样的；还有 delete 删除操作，删除一次和多次删除都是把数据删除了（不存在了），影响是一样的，典型的天然幂等操作。

- 使用唯一键值。比如，在数据库中加唯一索引，或是使用 UUID 做唯一 ID，都可以防止在新增数据时出现不必要的脏数据，因为不同的服务节点操作数据时都收到了唯一 ID 的约束。

- 使用加锁策略。比如，悲观锁、乐观锁、分布式锁等。加锁的目的就是让不同的服务在同一个数据变更时不被其他服务所影响，比如，订单服务 API 部署了 500 个相同实例，那么即便通过 Nginx 网关做了负载均衡的流量分配，在修改订单的时候如果不加锁，就会导致数据被重复多次的修改，也就是无法保证幂等。

- 使用 Source+Token 验证机制。这和使用唯一键值有一点类似**，**不过这种方法更多用在对外提供的 API 中去保证幂等性。这两个字段实际上既做了联合的唯一索引，又做了使用来源的日志记录，这样既能保证接口的幂等性，也能记录不同客户端使用 API 的调用情况。

- 使用有限状态机。在一些状态变更比较频繁的业务中，会经常使用到状态机，比如，订单、支付、秒杀等业务。当状态机已经处于下一个状态，这时候又来了一个上一个状态的变更，那么这时就不允许再进行状态变更了。正是通过这种状态扭转的约束，保证了接口服务的幂等性。

## 3 设计模式

### 3.1 单例模式

- 一个单例类只能有一个实例
- 单例类必须自行创建这个实例
- 单例类必须保证全局其它对象都能唯一访问到它



**为什么要使用单例模式？**

系统某些资源有限：

- 控制某些共享资源（例如，数据库或文件）的访问权限
- 同时读写同一个超大的 `AI` 模型文件，或使用外部进程式服务

需要表示为全局唯一的对象：

- 系统要求提供一个唯一的序列号生成器



**使用单例模式的优势：**

- 对有限资源的合理利用，保护有限的资源，防止资源重复竞抢。

- 更高内聚的代码组件，能提升代码复用性。

- 具备全局唯一访问点的权限控制，方便按照统一规则管控权限。

- 从负载均衡角度考虑，我们可以轻松地将 Singleton 扩展成两个、三个或更多个实例。由于封装了基数问题，所以在适当的时候可以自由更改实例的数量。



**使用单例模式的劣势：**

- 作为全局变量使用时，引用的对象越多，代码修改影响的范围也越大。

- 作为全局变量时，在全局变量中使用状态变量时，会造成加/解锁的性能损耗。

- 即便能扩展多实例，但耦合性依然很高，因为隐蔽了不同对象之间的调用关系。

- 不支持有参数的构造函数。

#### 饿汉式



```java
// 饿汉式： 类在第一次初始化时就已经创建好唯一的单例
public class Singleton1 {
    private static Singleton1 instance = new Singleton1();

    private Singleton1() {

    }

    public static Singleton1 getInstance() {
        return instance;
    }
}
```



#### 懒汉式



```java
// 懒汉式： 需要的时候在创建唯一单例
public class Singleton2 {

    private static Singleton2 instance;

    private Singleton2() {

    }

    // 线程不安全，可能创建多个“单例”
    public static Singleton2 getInstance() {
        if (instance == null) {
            instance = new Singleton2();
        }
        return instance;
    }

    // 线程安全同步信号, 但是锁重量级
//    public static synchronized Singleton2 getInstance() {
//        if (instance == null) {
//            instance = new Singleton2();
//        }
//        return instance;
//    }
}
```



#### 同步信号

```java
//    public static synchronized Singleton2 getInstance() {
//        if (instance == null) {
//            instance = new Singleton2();
//        }
//        return instance;
//    }
```



#### 双重锁定(DCL)

```java
// 双重锁实现：
public class Singleton3 {

    // volatile: 禁止指令重排
    private static volatile Singleton3 instance;

    private Singleton3() {

    }
	// 为何要进行两次判空？
    // 多线程模式下，第一次判空，可以将同步信号锁放置方法内部，提高性能；第二次判空，防止多个线程同时进入第一个判空条件，执行 new 实例
    public static Singleton3 getInstance() {
        if (instance == null) {
            synchronized (Singleton3.class) {
                if (instance == null) {
                    instance = new Singleton3();
                }
            }
        }
        return instance;
    }

}
```



#### 使用 ThreadLocal



**ThreadLocal 会为每一个线程提供一个独立的对象副本**，从而解决了多个线程对数据的访问冲突的问题。正因为每一个线程都拥有自己的对象副本，也就省去了线程之间的同步操作。

```java
import java.util.HashMap;

import java.util.Map;

public class AppContext {

    private static final ThreadLocal<AppContext> local = new ThreadLocal<>();

    private Map<String,Object> data = new HashMap<>();

    public Map<String, Object> getData() {

        return getAppContext().data;

    }

    //批量存数据

    public void setData(Map<String, Object> data) {

        getAppContext().data.putAll(data);

    }

    //存数据

    public void set(String key, String value) {

        getAppContext().data.put(key,value);

    }

    //取数据

    public void get(String key) {

        getAppContext().data.get(key);

    }

    //初始化的实现方法

    private static AppContext init(){

        AppContext context = new AppContext();

        local.set(context);

        return context;

    }

    //做延迟初始化

    public static AppContext getAppContext(){

        AppContext context = local.get();

        if (null == context) {

            context = init();

        }

        return context;

    }

    //删除实例

    public static void remove() {

        local.remove();

    }

}

```



#### 静态内部类



```java
//第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonInner 并初始化instance
public class Singleton4 {

    private Singleton4() {

    }

    public static Singleton4 getInstance() {
        return SingletonInner.instance;
    }

    private static class SingletonInner {
        private static final Singleton4 instance = new Singleton4();
    }
}

```



#### 枚举



```java
package singleton;

public enum Singleton5 {
    INSTANCE;
}

```

### 3.2 建造者模式

Builder 模式，也叫**生成器模式**。

**为什么直接使用构造函数或使用set方法创建对象不方便？** 

- 直接使用构造函数的话面对多种可选参数的情况，需要也多种不同的构造函数，使用时容易造成混乱
- 使用set方法，也就是javabean模式的话，在构建过程中对象的状态容易发生变化，造成错误。因为类中的属性是分步设置的。（对象在创建好之后，就不能再修改内部的属性值，所以不能暴露 set 方法）

为什么一定需要建造者模式来创建？

- **分阶段、分步骤的方法更适合多次运算结果类创建场景**。在面向对象软件开发中，很多时候创建类所需要的参数并不是一次都能准备好的，比如，计算订单优惠价格、查询库存状态等，有的参数可能需要通过调用多个服务运算后才能得出，这时我们可以根据已知参数预先对类进行创建，等有合适的参数时再设置类的属性，而不是等到所有结果都齐备后才去创建类。
- **不需要关心特定类型的建造者的具体算法实现**。 比如，我们在使用 StringBuilder 时，并不太关心它的具体代码实现，而是关心它提供给我们的使用功能。这在某些需要快速复用的场景中，能起到提升编码效率的作用。而换个角度来看，当你需要给别人提供一个建造者来创建类时，你就需要严格地设计你的建造者，并保证你的建造者类能够创建符合预期的类。





**定义：**将复杂对象的构造与其表示分离，以便同一构造过程可以创建不同的表示。

**传统建造者模式UML图：**



![image-20220117174153207](X:\JavaNote\design-mode\image\image-20220117174153207.png)

- **Product**：代表最终构建的对象，比如，汽车类。

- **Builder**：代表建造者的抽象基类（可以使用接口来代替）。它定义了构建 Product 的步骤，它的子类（或接口实现类）需要实现这些步骤。同时，它还需要包含一个用来返回最终对象的方法 getProduct()。

- **ConcreteBuilder**：代表 Builder 类的具体实现类。

- **Director**：代表需要建造最终对象的某种算法。这里通过使用构造函数 Construct(Builder builder) 来调用 Builder 的创建方法创建对象，等创建完成后，再通过 getProduct() 方法来获取最终的完整对象。



![image-20220117174502007](X:\JavaNote\design-mode\image\image-20220117174502007.png)

**建造者模式封装（信息隐藏）了如下变化：**

- 每个具体建造器的构建步骤；

- 当前正在使用哪一个建造器；

- 现有建造器的数量；

- 一个建造器里可以创建多个属性的特性。



**建造者模式常用使用情况：**

- 需要生成的对象包含多个成员属性，而且这些参数有些是可选参数，考虑使用建造者模式；
- 需要生成的对象的属性相互依赖，需要指定其生成顺序；
- 对象的创建过程独立于创建该对象的类；
- 需要隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。



**优点：**

- **分离创建与使用。** 在建造者模式中， 使用方不必知道你的内部实现算法（步骤）的细节，通过统一方法接口的调用，可以自由组合出不同的对象实例。

- **满足开闭原则**。 每一个建造者都相对独立，因此能方便地进行替换或新增，这就大大提升了代码的可扩展性。

- **自由地组合对象的创建过程。**由于建造者模式将复杂的创建步骤拆分为单个独立的创建步骤，这不仅使得代码的可读性更高，也使得在创建过程中，使用者可以根据自己的需要灵活创建。

**缺点：**

- **使用范围有限**。 建造者模式所创建的对象一般都需要有很多的共同点，如果对象实例之间的差异性很大，则不适合使用建造者模式。
- **容易引起超大的类。**我们都知道一辆汽车内部构造其实很复杂，作为开发者的你其实更关心的是像发动机、轮胎这样具备重用性的组件。一旦过度定制化对象创建的过程步骤，那么随着创建对象新需求的出现或变化，新的创建步骤就会被加进来，这会造成代码量的急剧膨胀，最终形成一个庞大的超大类。
- **增加代码行数。** 虽然建造者模式能够提高代码的可阅读性，但也会以增加代码行数来作为代价。



### 3.3 抽象工厂模式



**工厂模式：**

- 工厂方法模式
- 抽象工厂模式

抽象工厂模式的重点和难点是——**如何找到正确的抽象**

定义： 提供了一个用于创建相关或相关对象族的接口而无需指定其具体类

![image-20220118165156739](X:\JavaNote\design-mode\image\image-20220118165156739.png)

抽象工厂模式主要包括四个关键：

- 抽象工厂；

- 抽象产品（通用的一类对象或接口）；

- 具体工厂；

- 具体产品（继承通用对象或接口后扩展特有属性）。

**如何找到某一个类产品的正确共性功能**

**在软件开发中，抽象工厂模式的使用场景主要就是解决跨平台兼容性的问题。**



为什么要使用抽象工厂模式？

- **第一点，对于不同产品系列有比较多共性特征时，可以使用抽象工厂模式，有助于提升组件的复用性。** 比如，不同的数据库产品，JDBC 就是对于数据库增删改查建立的抽象工厂模式，无论使用什么类型的数据库，只要具体的数据库组件能够支持 JDBC，就能对数据库进行读写操作，这极大地提高了我们对不同数据库组件的复用性。

- **第二点，当需要提升代码的扩展性并降低维护成本时，把对象的创建和使用过程分开，能有效地将代码统一到一个级别上。**比如，你需要创建统一的日志监控，但不同应用使用的日志收集代理可能各不相同，这时如果有一个统一的日志收集工厂定义抽象的日志收集功能，那么不同的代理只需要按照各自的实现方式提供统一的日志收集功能即可，这样即便以后新增了一些代理，也不会影响旧的功能，提升扩展性的同时也能提升维护性。

- **第三点，解决跨平台带来的兼容性问题。** 抽象工厂模式提供了一种解决跨平台问题的思路，也就是我们的后台服务应该尽可能地使用更高层级的统一的抽象功能，然后通过不同客户端的适配程序来实现统一的功能交付。比如，同一个地区里，安卓或 iOS 的客户端 App 通过 API 网关访问商品数据时，应该是先获取统一的抽象数据对象，然后经过安卓或 iOS 的客户端适配器程序的适配转换和传输，而不是针对具体型号的手机（华为、小米、苹果等）来单独进行适配，安卓和 iOS 这里就被看作是不同手机型号的抽象工厂模式。



**优点：**

- **符合开闭原则。** 当我们需要添加新的工厂类时，只用新继承一个类，不用修改抽象工厂和其他具体类。

- **可以保证同一工厂生成的产品符合预期。** 通过抽象工厂定义了统一的抽象产品功能，只要是继承了这个抽象工厂，本质的抽象产品功能是不会发生改变的。

- **将使用和创建的代码进行解耦**。 在具体的代码实现中，使用者只用关心如何使用具体的功能，而不再需要关心这个对象是怎么创建的。这样对象与对象之间的耦合关系变得更单一，降低了过多应用带来的耦合风险。

- **满足单一职责原则**。 由于我们将产品的实现代码放到同一层级里，并继承同一个抽象工厂类，所以说，即便具体的代码风格有所不同，也不影响最终提供功能的统一性，使得代码的可维护性大大提高。

- **容易增加新的产品系列**。 因为有了抽象工厂作为参考模板，那么再新增新的具体工厂时非常容易，不需要修改其他具体工厂，并且各自的工厂可以朝着自己的演化方向发展。

缺点：

- 增加代码量。 虽然抽象工厂模式很好地进行了职责分离，但因此也增加了更多的类文件和代码行数，使得开发时间变长，并且随着实现子类越来越多，可能当一个抽象工厂想要增加抽象时，影响的代码范围会很大。

- 增加学习成本。 抽象工厂模式是自顶向下式的设计，无论是入门级的程序员还是资深程序员，一开始就找到正确的抽象是一件非常困难的事情。这可能需要学习大量的实践案例，并不断总结归纳才有可能做得更好。

- 变更产品的结构困难。 抽象工厂模式最大的缺点在于，一旦定义了某种产品结构后，要想修改就得修改所有的具体工厂和抽象工厂。比如，家具工厂需要再生产“门”这个家具，那么不管是已有的中国工厂还是美国工厂，都需要新增生产“门”的家具，势必会引入风险。其实，这本质上就是继承带来的问题。

### 3.4 工厂方法模式

重要程度：  ☆  ☆  ☆  ☆

factory method pattern  也叫作 工厂模式

**定义：** 定义一个创建对象的接口，但让实现这个接口的类来决定实例化那个类

![image-20220118181944874](X:\JavaNote\design-mode\image\image-20220118181944874.png)

工厂模式的三个关键：

- 抽象接口（也叫抽象产品）；

- 核心工厂；

- 具体产品（也可以是具体工厂）。

不同于抽象工厂模式，工厂方法模式侧重于直接对**具体产品的实现进行封装和调用**，通过统一的接口定义来约束程序的对外行为。换句话说，用户通过使用核心工厂来获得具体实例对象，再通过对象的统一接口来使用对象功能。

**工厂方法模式是围绕着特定的抽象产品（一般是接口）来封装对象的创建过程，客户端只需要通过工厂类来创建对象并使用特定接口的功能。**



**为什么要使用工厂方法模式？**

- **第一个，为了把对象的创建和使用过程分开，降低代码耦合性。**这是使用工厂方法模式最直接的理由之一。在实际的软件开发中，你可能更喜欢使用 new 来创建对象，同时紧接着便开始使用新创建的对象，这看上去并没有什么问题，但是随着创建对象数量的增多，你会发现，当你想要重构、修改已有的对象属性和方法时，你几乎不敢轻易修改，因为你早已记不清哪些对象在哪里被创建和使用，以及跟哪些对象发生了关联和交互。而使用工厂方法模式，就能很好地避免这个问题，创建的过程始终在工厂内部管理，只要对外使用的方法不发生变化，那么就不会对创建对象造成影响。

- **第二个，减少重复代码。** 对于要写代码的程序员或架构师来说，面对成千上万相同的数据对象进行增删改查时，如果每次都使用 new 来创建对象的话，那么 80% 的时间都会浪费在同样属性的 get 与 set 上。这时要是使用的对象之间还有相互引用的话（A 引用 B，B 又引用 C……），重复的代码就会剧增。而对于多个相同对象的构建过程，除了使用建造者模式以外，还可以使用工厂方法模式来避免出现过多的重复代码，将相同的创建规则统一放在一起。
- **第三个，统一管理创建对象的不同实现逻辑。** 比如，当一个业务对象发生业务逻辑变化时，使用工厂方法模式后，你不需要找到所有创建对象的地方去修改，而只需要在工厂里修改即可。即便这时你想要扩展对象为新的子类，也不需要把所有调用父类的地方都改成子类，只需要在工厂中修改其生产的对象为新的子类。同时，还隐藏了具体的创建过程，减少了使用者误用逻辑而导致未知错误出现的概率。



**优点:**

- **能根据用户的需求定制化地创建对象。** 工厂方法模式是基于某一个抽象产品角色来进行具体的实现工厂的设计。这样的好处就在于具体工厂可以根据自己的需求来决定创建什么样的具体产品，同时，还能把不同的算法细节完全封装在具体的工厂内部。

- **隐藏了具体使用哪种产品来创建对象。** 由于工厂方法模式对外使用统一的抽象接口，这样就向用户隐藏了具体正在使用的产品实例，让用户只需要关心抽象接口即可，无须关心创建细节，甚至都不用知道具体产品类的真实类名。

- **实现同一抽象父类的多态性，满足“里氏替换原则（LSP）”**。 在使用工厂方法模式时，因为是围绕着统一的抽象接口来实现具体的功能，那么就能很便捷地使用不同的算法策略来实现同一功能，所以这样更好地实现了不同具体产品之间的可替换性。

- **满足“开闭原则”。** 当你想要在系统中加入新的具体对象时，不用再修改抽象接口和核心工厂，也不用修改客户端，更不用修改其他具体工厂和具体产品，而只需要新增一个具体工厂和具体产品就可以了。这样系统的可扩展性也就变得非常好，完全符合“开闭原则”。

**缺点：**

​	

- **抽象接口新增方法时，会增加开发成本。** 当统一的抽象接口中新增方法时，相应的每个具体工厂都需要新增实现。不管具体工厂是否需要这个方法，都必须要新写代码，这样在一定程度上增加了开发工作量，因为修改后就需要编译、运行和测试，自然增加了开发成本。

- **具体工厂实现逻辑不统一，增加代码理解难度。** 虽然核心工厂已经保证了部分共有逻辑的实现，但是具体产品依然是由具体工厂封装实现的，一旦具体工厂采用非通用的实现策略，那么对于维护的人员来说，就需要耗费大量的精力和时间去学习和理解。

### 3.5 简单工厂模式

作用和工厂方法模式一样；不过是使用静态方法生产产品，也就是实例对象；

![image-20220118194211122](X:\JavaNote\design-mode\image\image-20220118194211122.png)

简单工厂的核心点：

- 抽象产品
- 具体产品
- 简单工厂



简单工厂模式的核心就是通过一个工厂方法根据不同的条件生产**同一类型**的产品。例如此例中我们要生产的小米笔记本和苹果笔记本他们是同一类型的产品，会实现**同一个**接口。

优点： 避免了直接在客户端创建具体的产品实例，降低了耦合性

缺点：违反了开闭原则，不容易形成高内聚低耦合的结构，每当我们需要新增一种产品时，就需要修改工厂方法，破坏了内聚性。

### 3.6 原型模式

定义： 使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。

![image-20220119123752419](X:\JavaNote\design-mode\image\image-20220119123752419.png)

原型模式中的关键：

- 使用者
- 原型
- 新实例

**使用者需要建立一个原型，才能基于原型拷贝出新实例。**



**原型模式封装了如下变化：**

- 原始对象的构造方式；

- 对象的属性与其他对象间的依赖关系；

- 对象运行时状态的获取方式；

- 对象拷贝的具体实现策略。

**原型模式从建立原型到拷贝原型生成新实例，都是对用户透明的，一旦中间任何一个小细节出现问题，你可能获取的就是一个错误的对象。**



为什么要使用原型模式？

- **第一个，减少每次创建对象的资源消耗。** 当类初始化消耗资源特别多时，原型模式特别有用。比如，在 AI 系统中，我们经常需要频繁使用大量不同分类的数据模型文件，在对这一类文件建立对象模型时，不仅会长时间占用 IO 读写资源，还会消耗大量 CPU 运算资源，如果频繁创建模型对象，就会很容易造成服务器 CPU 被打满而导致系统宕机。通过原型模式我们可以很容易地解决这个问题，当我们完成对象的第一次初始化后，新创建的对象便使用对象拷贝（在内存中进行二进制流的拷贝），虽然拷贝也会消耗一定资源，但是相比初始化的外部读写和运算来说，内存拷贝消耗会小很多，而且速度快很多。

- **第二个，降低对象创建的时间消耗。** 比如，需要查询数据库来创建对象时，如果数据库正好繁忙或锁表中，那么这个创建过程就可能出现长时间等待的情况。在很多高并发场景中，稍微长时间的等待可能都是致命的，因为大量的数据和请求如洪水一般涌入服务器，很容易引起雪崩效应。这时使用原型模式就是相当于对对象创建的过程进行了一次缓存读取，而不必一直阻塞程序的执行。

- **第三个，快速复制对象运行时状态。**原型模式相比于传统的使用 new 关键字创建对象还有一个巨大的优势，那就是当构造函数中包含大量属性或定制化业务逻辑时，不用完全了解创建过程也能快速创建对象。比如，当一个对象类有 30 个以上的属性或方法时（属性字段可能为另一个对象），如果你都通过 get 和 set 方法来创建对象，你会发现复制粘贴都是一件痛苦的事，因为你可能都忘记了哪些字段是必选、哪些又是有数据的。这也是我们在接收 HTTP 和 RPC 传输的 JSON 数据时，更愿意采用反序列化（也是一种原型模式的实践）到对象的方式，而不是 new 一个新对象再赋值的原因。

- **第四个，能保存原始对象的副本。** 在某些需要保存历史状态的场景中，比如，聊天消息、上线发布流程、需要撤销操作的程序等，原型模式能快速地复制现有对象的状态并留存副本，方便快速地回滚到上一次保存或最初的状态，避免因网络延迟、误操作等原因而造成数据的不可恢复。



**优点：**

- **原型并不基于继承，因此没有继承的缺点。**原型模式是对对象的直接复制，当新对象发生变化时，并不会对原始对象有任何影响，而继承的对象一旦发生了修改则会影响到父类。

- **复制大对象时，性能更优。**比如，Java 使用的原型模式是基于内存二进制流的拷贝，而直接 new 一个大对象是 JVM 进行堆内分配并可能触发 Full GC，相比之下，使用 new 关键字时所做的操作实际上更多，而使用内存拷贝的方式在复制的性能上会更优。

- **可以快速扩展运行时对象的属性和方法。**原型模式一方面简化了对象的创建过程，另一方面能够保留原始的对象状态，这样的优势是：在程序运行过程中，如果想要动态扩展对象的功能（增减方法或属性值），可以在不影响原有对象的情况下，动态扩展对象的功能。比如，结合 AOP 切面编程可以实现录制业务调用轨迹，加入应用性能监控，做动态数据埋点等操作。

**缺点：**

- **虽然不基于继承，但原型需要一个被初始化过的正确对象。**如果被复制的对象在进行复杂的初始化时失败或出现错误的初始化后，那么复制的对象也可能是错误的。

- **复制大对象时，可能出现内存溢出的 OOM 错误。**虽然复制对象有诸多优点，但是不要忘记内存的大小是有限制的，如果你想要复制的对象已经占用了 80% 的内存空间，那么复制时大概率会导致内存溢出，而这时的解决办法要么是增加内存，要么是拆分对象。

- **动态扩展对象功能时可能会掩盖新的风险**。虽然原型模式能够在运行时帮助我们快速扩展功能，但同时也可能使新对象的负荷更重。比如，埋点服务中我们通常会拷贝一份对象在某个时间节点的数据，并添加一些追踪数据后再推送给埋点服务，这样就可能增加过多的内存消耗，影响原有功能执行的性能，有时还可能引起 OOM，导致系统宕机。切记，如果没有充分验证过动态扩展功能的话，那么就不要轻易使用动态扩展，因为加入额外的新功能，大概率是会影响原有功能的。

### 3.7 [❤]创建型设计模式总结

**单例模式（Singleton）**，类似于一种技巧，是工厂模式一种数量上的特例，相当于强制实现了有限、唯一对象的生产。

**建造者模式（Builder）**，侧重点在于如何实现对象创建过程的自由组合，避免在代码中出现大量 new 式的硬编码。当对象结构发生改变时，能灵活增删步骤节点，还能避免对程序中大量分散 new 语句的修改。换句话说，它实现了对象创建过程的多态。

**抽象工厂模式（Abstract Factory）**，重点是创建一组实现统一抽象产品的工厂对象族（同一个逻辑层级），本质上是为了寻找正确的抽象产品。它可以很好地保证被创建对象的工厂之间的一致性，常常用来解决跨平台的设计问题。

**工厂方法模式（Factory Method）**，有效解决了创建对象时的不确定性。使用的办法就是将创建对象的时机延迟到了每一个具体的创建工厂中，让具体工厂自行解决对象的复杂创建过程，并通过统一的定义接口来保证创建对象时的可任意替换性。换句话说，它实现了对象创建时的多态。

**原型模式（Prototype）**，就是一种将对象生成的责任代理给自己的模式，也就是“复制自我”。通过复制能快速建立运行的对象副本，最大的作用在于动态扩展运行时的对象能力。换句话说，它实现了对象拷贝的多态。



### 3.8 适配器模式

**定义：**将类的接口转换为客户期望的另一个接口，适配器可以让不兼容的两个类一起协同工作。

![image-20220119173529055](X:\JavaNote\design-mode\image\image-20220119173529055.png)

**适配器模式中包含三个关键角色：**

- 目标类， 适配器类即将要进行适配的抽象类或接口；

- 适配器类， 可以是类或接口，是作为具体适配者类的中间类来使用；

- 具体适配者类， 可以是内部的类或服务，也可以是外部对象或服务。



**适配器模式的使用场景主要有这两大类：**

- 第一类就是原有接口功能不满足现有要求，需要在兼容老接口的同时做适当的扩展；

- 第二类是有相似性的多个不同接口之间做功能的统一。



**为什么要使用适配器模式？**

- **第一，原有接口无法修改但又必须快速兼容部分新功能。** 有时某些接口会因为一些因素而无法修改，比如，已交接的系统、跨团队、外部公用接口等，但这种情况下又需要适当扩展现有接口的功能，该怎么办呢？能想到的第一个办法就是使用适配器模式进行扩展。适配器模式也被称为“最好用打补丁模式”，就是因为只要是一个接口，都可以用它来进行适配。不过，要注意的是适配的新接口和目标接口差异不大时，扩展才更有效，不要被“适配器就是万能接口”的思维所误导，这就像你非要适配 10 年前的软盘接口一样不现实，也没有必要。

- **第二，需要使用外部组件组合成新组件来提供功能，而又不想重复开发部分功能。** 比如，构建自然语言识别功能时，你不想从零开始训练庞大的中文语义模型来实现 NLP 接口，这时你就可以选择使用外部第三方公共平台提供的 NLP 接口，然后组合实现你自己的 NLP 接口，形成新的组件。虽然这样效率很高，但是依赖外部系统的风险同样突出（如果外部功能变更或下线，则组件可能不可用），只是作为短期的过渡方案，适配器模式可以说是绝佳选择。

- **第三，不同数据格式、不同协议需要转换**。 比如，API 网关中经常需要对 iOS、安卓、H5 等不同的客户端进行数据和通信协议上的适配转换，这时网关就是一个-是适配器，适配客户端的同时适配服务端。



优点：

- **将目标类和具体适配者类解耦。** 通过引入一个适配器类来兼容现有的目标类，重用原有类功能的同时扩展新功能，而无须修改原有目标类代码，这样很好地避免了具体适配者类和目标类的直接耦合。

- **增加了类的透明性。** 具体的适配者类中新增功能只影响适配者类，而对于使用目标类的客户端类来说是透明的（使用目标类接口），客户端的调用逻辑不会受到影响。

- **满足里氏替换原则。** 具体适配者类通过适配器类与目标类进行交互，那么适配器类只要不影响目标类的接口功能，具体适配者类无论使用什么样的新功能，都能很方便快速地进行替换。

- **符合开闭原则。** 由于具体适配者类要么是适配器类的子类，要么和适配器类是组合关系，所以对目标类没有修改，满足开闭原则。

- **统一多个类或接口。** 一个适配器类可以把多个不同的具体适配者类和子类，都适配到同一个目标类上，如果这个目标类是一个新类，那么就是间接实现了统一多个类或接口的功能。

缺点：

- **一次只能适配一个抽象类或接口。** 像 Java、C# 等编程语言是不支持多重继承的，那么在进行适配时，一次最多只能适配一个适配者类。另外，目标类只能为抽象类或接口，不能为具体实例类，这样会在适配时增加很多类文件和代码量，如果适配的类或接口比较多，那么就会增加代码的理解难度。

- **过度嵌套会导致接口臃肿。** 适配器有一个最大的弊端就是，一旦不停地在同一个目标类上增加适配器，就会很容易让接口变得越来越臃肿。

- **目标接口依赖太多适配接口，修改目标接口会导致所有适配接口都需要定制修改。** 本来适配器模式是为了解耦，但是如果适配太多接口，就会演变为另一种定制化的开发。比如，上游平台商家提供的接口变更，导致下游使用方频繁变更接口。再比如，消息组件接口的变更导致所有引用消息组件的适配器全部都需要修改。



### 3.9 桥接模式

定义： 将抽象部分与它的实现部分分离，使他们都可以独立地变化；它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interfce)模式。

解释： **从对象与对象间的关系去看，做抽象实体与抽象行为的分离，所以使用抽象实体和抽象行为来描述更为准确。**

![image-20220120001000455](X:\JavaNote\design-mode\image\image-20220120001000455.png)

**桥接模式有以下四个关键角色：**

抽象实体：定义的一种抽象分类。比如，电脑中的 CPU、内存、摄像头、显示屏等。

具体实体：继承抽象实体的子类实体。比如，Intel i7 CPU、三星内存、徕卡摄像头、京东方显示屏幕等。

抽象行为：定义抽象实体中具备的多种行为。比如，CPU 逻辑运算、内存读写存储、摄像头拍照、屏幕显示图像等。

具体行为：实现抽象行为的具体算法。比如，Intel 使用 X64 架构实现 CPU 逻辑运算，Mac M1 芯片使用 ARM 架构实现 CPU 逻辑运算，等等。

**抽象的分离间接完成了具体类与具体类之间的解耦，它们之间使用抽象来进行组合或聚合，而不再使用继承。**



**桥接模式的本质是通过对一个对象进行实体与行为的分离，来将需要使用多层继承的场景转换为使用组合或聚合的方式，进而解耦对象间的强耦合关系，达到对象与对象之间的动态绑定的效果，提升代码结构的扩展性。**



为什么要使用桥接模式？



**第一个，为了灵活扩展代码结构**

**第二个，为了更好地解决跨平台兼容性问题。** 桥接模式之所以能很好地解决跨平台的兼容性问题，就是因为桥接模式通过抽象层次上结构的分离，让相关的分类能够聚合到各自相关的层次逻辑中，而不同的平台对于同一个 API 在具体的代码实现上是不同的，这样反而符合不同操作系统按照各自维度演化的特性。

**第三个，为了在运行时组合不同的组件。** 无论是框架还是外部服务，我们都需要基于一个统一的协议进行协同工作，但是通过静态的继承方法很难做到在程序运行时进行方法或组件的动态更换。而使用桥接模式和门面模式就可以很方便地进行替换，比如，在上面文件上传执行器的案例中，我们可以使用一个统一的 API 网关调用不同的云服务来完成文件上传。



优点：

- **分离实体与行为，可以提升各自维度的演化效率。** 比如，订单中的会员信息可以理解为抽象实体，普通会员和 plus 会员就是不同的具体实体；会员中的积分累计就是抽象行为，不同会员按照各自的积分计算轨迹进行计算就是具体行为的体现。那么，会员可以再继续增加更多会员类别，而积分计算规则也可以不断更新。

- **符合开闭原则，提升代码复用性。** 每一个维度的类都以组合或聚合关系进行合作，新增类或修改类都在各自类内部进行，不影响其他类。

- **用组合关系替代了多重继承，提升了代码结构的演化灵活性。**我们都知道多继承违背了单一职责原则，虽然关联性更强，但复用性很差。组合关系的优势就在于可以在任意阶段进行升级与替换，并且可以按需进行组合与撤销，这对于需求快速变化的开发场景而言很适用，能够极大地提升代码结构的灵活性。

- **符合表达原则，提升代码的可理解性。**由于桥接模式从抽象层次就进行了分离，不同的类别会按照各自的特点进行演化，所以不管是在结构上还是代码内在含义上，都更聚焦，这样在阅读代码时也就能更容易理解。

缺点：

- **增加了维护成本。** 桥接模式因为需要做很多实体和行为的分离，所以会间接地要增加不少代码行数。再加上使用组合和聚合关系不像继承关系那样容易找到对象之间的调用关系，稍不注意就会影响到其他对象，这样大大增加了代码修改维护的成本。

- **导致性能下降。** 组合或聚合关系在面向对象编程中使用的是委托的实现方式，简单理解就是调用的对象变多了，自然也就影响到了程序的性能。

- **增加设计难度。** 桥接模式更重视聚合而非继承关系，那么就需要建立更多的抽象层，要求开发者针对抽象层进行设计与编程。我们都知道，找到正确的抽象层有时是一件相当困难的事情，虽然现在有很多优秀的设计能够作为借鉴，但在一些新的领域里依然会有一定的设计难度。



### 3.10 组合模式

定义： 将对象组合成树形结构以表示整个部分的层次结构。组合模式可以让用户统一对待单个对象和对象的组合。



使用场景：

- 当你的程序结构有类似树一样的层级关系时，例如文件系统，视图树，公司组织架构等等
- 当你要以统一的方式操作单个对象和由这些对象组成的组合对象的时候。



![image-20220120115059794](X:\JavaNote\design-mode\image\image-20220120115059794.png)

**组合模式的三个关键角色：**

- 抽象组件： 定义需要实现的统一操作
- 组合节点：  代表一个可以包含多个节点的复合对象，意味着在它下面还可以有其他组合节点或叶子节点。
- 叶子节点：   代表一个原子对象，意味着在它下面不会有其他节点了。

除了树形结构以外，组合模式中还有环形结构和双向结构，其中，环形结构和数据结构中的单向链表很相似，而双向结构其实就是 Spring 中 Bean 常用的结构。



**为什么要使用组合模式？**

- 第一， 希望一组对象按照某种层级结构进行管理。比如，管理文件夹和文件，管理订单下的商品等。
- 第二，需要按照统一的行为来处理复杂结构中的对象。
- 第三，能够快速拓展对象组合。

优点：

- 清晰定义分层结构
- 简化了使用者使用复杂结构数据的代码
- 快速新增节点，提升组合的灵活性

缺点：

- 难以限制节点的类型
- 需要增加很多运行时检查，增加了代码的复杂度
- 错误的遍历算法可能会影响系统性能



### 3.11 装饰器模式

定义： **允许动态地向一个现有的对象添加新的功能，同时又不改变其结构，相当于对现有的对象进行了一个包装。也叫做包装器模式**

![image-20220120155405538](X:\JavaNote\design-mode\image\image-20220120155405538.png)

装饰器模式有四个关键角色：

- 组件：  作为装饰器类包装的目标类
- 具体组件： 实现组件的基础子类
- 装饰器： 一个抽象类，其中包含对组件的引用，并且还重写了组件接口方法。
- 具体装饰器：继承拓展了装饰器，并且重写组件接口方法，同时可以添加附加功能。



装饰者模式的精髓在于**动态的给对象增减功能**。

**使用场景：**

- **快速动态扩展和撤销一个类的功能场景。** 比如，有的场景下对 API 接口的安全性要求较高，那么就可以使用装饰模式对传输的字符串数据进行压缩或加密。如果安全性要求不高，则可以不使用。

- **可以通过顺序组合包装的方式来附加扩张功能的场景。** 比如，加解密的装饰器外层可以包装压缩解压缩的装饰器，而压缩解压缩装饰器外层又可以包装特殊字符的筛选过滤的装饰器等。

- **不支持继承扩展类的场景。** 比如，使用 final 关键字的类，或者系统中存在大量通过继承产生的子类。



为什么使用？

- 为了快速动态扩展类功能，降低开发的时间成本。

- 希望通过继承的方式扩展老旧功能。



优点：

- **快速扩展对象的功能。** 对于一些独立且无法修改的类来说，当需要在短期内扩展功能时，采用装饰模式能快速有效地扩展功能，同时也不会影响原有的功能。

- **可以动态增删对象实例的功能。** 比如，在上面文件读写器的例子中，我们可以在创建对象的时候再决定是一起使用压缩装饰器和加密装饰器，还是分开使用，或者只是用基本的读写功能。

- **可以在统一行为上组合几种行为。** 装饰模式是对某一个接口行为进行的组合扩展，通过包装的方式不断扩展代码的行为，从而实现了更多行为的组合。

- **满足单一职责原则。** 每一个具体装饰器类只实现一个组件的具体行为，即便附加了新的功能也是围绕着组件的职责而做扩展，保证了职责的单一性。

缺点：

- **在调用链中删除某个装饰器时需要修改代码。** 装饰模式的最大弊端在于，当在某个组件上附加了太多装饰器后，想要删除其中的某个装饰器时，就需要修改前后的装饰器的引用位置，这样容易导致上下文中代码都需要修改的情况，大大增加了出错的可能性。

- **容易导致产生很多装饰对象，增加代码理解难度。** 由于使用了组合方式，并且在调用时使用了链式结构，这样间接增加了很多装饰器对象，而一旦不了解装饰模式的特性，就很容易误解为多个对象的参数调用，增加了代码的理解难度。

- **增加问题定位和后期代码维护成本。** 虽然装饰模式使用的组合方式比继承更加灵活，但同时也会增加代码的复杂性，在维护代码时会增加问题定位难度，同时调试时也需要逐级排查，比较烦琐，增加了后期代码维护成本。



> 装饰模式在结构上体现为 链式结构， 所以不建议装饰器过多。



### 3.12 门面模式【外观模式】

当我们需要用统一的标准来与系统进行交互时，可以采用外观模式。

定义：为子系统中的一组接口提供统一的接口

![image-20220120190555725](X:\JavaNote\design-mode\image\image-20220120190555725.png)

门面模式的关键角色：

- 门面系统【Facade】：引用各个子模块，然后对外提供统一的接口
- 子系统：要被隐藏的独立功能模块。

**门面模式的原理本质就是简化外部系统使用内部多个子系统的使用方式。**

比如：我们电脑主机开关就是一个门面模式，点击电脑会启动关闭，而无需考虑电脑如何运行CPU、启动内存、读取硬盘、点亮显示器。



为什么要使用门面模式？

- **为了解决遗留系统重构的问题。** 遗留系统通常是指承担着当前多个系统处理流程中重要的一环，但可能因为开发时间太过久远或初始维护团队发生重大调整，进而导致遗留下来的代码难以维护而得名。在重构遗留系统的过程中，内部子系统通常可能是非常复杂的，一般新维护的团队基本上不会修改原有系统的接口，但是新功能又必须要上线，这时就会采用门面模式先统一重要的接口，然后再逐渐地更新与迁移功能到新系统上，完成遗留系统的重构。这样既能保证原有线上系统不受影响，也能不断更新老旧的代码，让代码更易维护。结合我多年的经验来看，门面模式在设计上就是为了兼容更多不同的系统，非常适合重构遗留系统。

- **为了解决分层架构中的扩展问题。** 不管是单体应用还是分布式应用，使用分层架构时，容易出现各个层次的入口和出口被滥用的现象，比如，视图层滥用 DAO 层来访问数据存储。实际上，对于更高层的使用者来说，有时其实并不关心底层的实现逻辑。如果底层提供了太丰富的功能而又没有做限制时，就容易让高层的使用者混淆。而使用门面模式能够清晰地定义一类操作，比如，数据的增删改查门面系统，任务调度的门面系统。一方面，门面模式能够充当权限管控的角色（按类区分），让上层的访问能够汇聚到一个门面系统中，方便使用。另一方面，门面模式也能简化下层不同子系统的依赖关系（按分类关系聚合），避免滥用。这样在每一层里进行系统扩展时，就不会影响到其他系统。

优点：

- 极大地降低了客户端的复杂性

- **对使用者屏蔽子系统的细节，因而减少了使用者处理的对象数目，让整个系统使用起来更加方便。**比如，API 网关对外只有一个调用点，而后端服务可以用成百上千的服务系统连接网关。

- **实现了子系统与使用者之间的松散耦合关系。**比如，活动时用户只需要点击抢购按钮就能实现一键下单并送货，用户不用知道商品系统是如何扣减商品的，也不用知道物流系统如何调度送货的。

- **有助于建立层次结构系统，并简化层与层之间的依赖关系**。比如，视图层要访问存储层数据时，如果直接使用数据访问接口会造成依赖混乱，而按照某一个分类的服务建立一个门面服务层，比如，动态路由读写数据门面系统、数据埋点采集门面系统等，能够提供更简化统一的操作。

- **能够消除复杂的循环依赖。**比如，为多个外部系统提供统一的 SDK 应用包，统一定义不同的接口方法，指定对应的子系统进行使用。

- **有利于系统在不同平台之间的移植和重构。** 比如，系统早期通过 C# 实现，但现在团队期望通过 Java 进行重构，这时门面系统就可以充当中间的协议统一者，提供 HTTP 协议接口，然后逐渐迁移代码功能，使用过渡与升级同时并存的方式，完成系统的切换与升级。

缺点：

- 增加了一层，所以当子系统改变时，外观类相应的需要维护
- **降低了可靠性。**从架构模式上看，可能会出现过多的子系统依赖一个门面系统的情况，常见的网关模式就是这样，只要网关挂掉，所有子系统可能就无法使用了。
- **容易导致子系统越来越复杂。**有了简化的门面系统后，子系统可能就会不受约束地自由扩展。如果子系统在进行跨版本的升级而不通知门面系统时，就可能会造成系统的不可用。



**门面模式的本质是：简化调用，统一操作。**



### 3.13  享元模式

定义： 摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，从而让我们能在有限的内存容量中载入更多对象。

**享元模式要解决的核心问题就是节约内存空间，使用的办法是找出相似对象之间的共有特征，然后复用这些特征。**

![image-20220123213918822](X:\JavaNote\design-mode\image\image-20220123213918822.png)



享元模式的四个关键角色：

- 享元类（Flyweight）：定义了享元对象需要实现的公共操作方法。在该方法中会使用一个状态作为输入参数，也叫外部状态，由客户端保存，在运行时改变。

- 享元工厂类（Flyweight Factory）：管理一个享元对象类的缓存池。它会存储享元对象之间需要传递的共有状态，比如，按照大写英文字母来作为状态标识，这种只在享元对象之间传递的方式就叫内部状态。同时，它还提供了一个通用方法 getFlyweight()，主要通过内部状态标识来获取享元对象。

- 可共享的具体享元类（ConcreteFlyweight）：能够复用享元工厂内部状态并实现享元类公共操作的具体实现类。

- 非共享的具体享元类（UnsharedConcreteFlyweight）：不复用享元工厂内部状态，但实现享元类的具体实现类。



**内部状态：**不会随环境改变而改变的状态，俗称不可变对象。比如，在 Java 中 Integer 对象初始化就是缓存 -127 到 128 的值，无论怎么使用 Integer，这些值都不会变化。

**外部状态：**随环境改变而改变的状态。通常是某个对象所独有的，不能被共享，因此，也只能由客户端保存。之所以需要外部状态就是因为客户端需要不同的定制化操作。



> 享元模式要解决的问题是节约内存的空间大小，而缓存模式本质上是为了节省时间。



**使用场景：**

- 系统中存在大量重复创建的对象。比如，同一个商品的展示图片、详情介绍、文字介绍等，当自营商家系统调用或第三方商家调用时，商品系统可以使用同一个对象来节省内存空间。

- 可以使用外部特定的状态来控制使用的对象。比如，使用常用的中文汉字作为读取的标识，读取享元池中共享的多个中文汉字对象。

- 相关性很高并且可以复用的对象。比如，公司的组织结构人员基本信息、网站的分类信息列表等。



**为什么要使用享元模式？**

- **减少内存消耗，节省服务器成本。** 比如，当大量商家的商品图片、固定文字（如商品介绍、商品属性）在不同的网页进行展示时，通常不需要重复创建对象，而是可以使用同一个对象，以避免重复存储而浪费内存空间。由于通过享元模式构建的对象是共享的，所以当程序在运行时不仅不用重复创建，还能减少程序与操作系统的 IO 交互次数，大大提升了读写性能。

- **聚合同一类的不可变对象，提高对象复用性。** 比如，Java 中的 Number 对象族类（Integet、Long、Double 等）都是使用了享元模式例子，通过缓存不同范围数值来重复使用相同的数值。



**优点：**

- 可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。

- 通过封装内存特有的运行状态，达到共享对象之间高效复用的目的。

**缺点：**

- **以时间换空间，间接增加了系统的实现复杂度。**比如，需要分离出内部状态和外部状态，其中，外部状态这个定义比较模糊，也很难统一，而内部状态除了一些常用的常量容易被找到以外，那些更通用的组件对象在不同的业务系统中其实是不容易被找到的，因为不同的人对相似对象的理解并不一致，这就需要对程序员的代码设计实现思维有一定的要求。

- **运行时间更长，对于一些需要快速响应的系统并不合适。**享元模式的目的是节省空间，而没有说需要提供更短的时间，这适合数据类项目的使用，而不适合一些有高并发要求的系统。



### 3.14 代理模式

定义：让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许将请求提交给对象前后进行一些处理。

**代理模式是作为对象之间的一种中间结构来使用的，通过构建一个代理对象来对原始的功能进行委托处理，其中有一个很重要的功能就是控制对象的访问**

![image-20220123234557657](C:\Users\xyz\AppData\Roaming\Typora\typora-user-images\image-20220123234557657.png)

代理模式的三个关键角色：

- **抽象主题类（RealObject）：**声明公用的方法，定义可供客户端使用的统一功能。

- **主题实现类（RealObjectImpl）：**实现了抽象主题类的所有方法。

- **代理类（Proxy）：**实现了抽象主题类的方法，并隐藏在代理后面可能其他类的实现。



**为什么要使用代理模式？**

- **客户端有时无法直接操作某些对象。** 比如，在分布式应用中，你需要调用的对象可能是运行在另外一台服务器上的，当你访问它时，就必须要通过网络才能访问。如果你让客户端直接去调用，那么就意味着客户端需要处理网络服务，包括连接、打包、传包、解包等复杂操作；而这时如果你使用代理模式，在客户端和远程服务端之间建立一个网络代理对象，那么客户端只需要调用代理对象就能跟远程对象建立联系，甚至就像调用本地对象一样。这其实就是我们常说的 RPC 服务的基本原理，本质上就是代理模式。

- **客户端执行某些耗时操作容易造成服务端阻塞。** 比如，在类似有道、石墨、语雀这样的云编辑器里进行文案编写时，拷贝多张图片可能就是一件非常耗时的操作，使用者并不希望在执行拷贝图片的操作后，打字就无法正常操作甚至无法查看其他页面。这时，对于软件设计者来说，图片的加载就可以通过代理模式来解决：标示图片所在位置，然后使用代理对象去读取图片资源，这样就不会影响其他客户端与服务端之间的操作了。

- **服务端需要控制客户端的访问权限。** 代理模式除了前面提到的扩展功能外，另一个更为重要的功能是做权限控制。比如，某一项业务由于安全原因只能让一部分特定的用户去访问，如果在原有功能的基础上再增加权限过滤功能就会增加代码的耦合性，并且也不方便组件的复用。其实，这时做一个代理类就可以解决该问题，对于特定的接口来说，只需要指定所有请求必须通过该代理类，然后由该代理类做权限判断即可。

**代理模式的核心能力在于对某一个具体的功能进行增强和补充。**



**代理模式的分类：**

- **虚拟代理，适用于延迟初始化，用小对象表示大对象的场景。**这个“大对象”会包含大量 IO 资源，比如图片、大文件、模型文件等。我们都知道，大对象通常很占用内存空间，一直保持其运行会很消耗系统资源，这时就可以使用代理模式。那怎么来做呢？可以先创建一个消耗相对较小的对象来代理这个大对象的创建，而实际上真实的大对象只会在真正需要时才会被创建，这样的代理方式就被称为虚拟代理。比如，在 Java 中的 CopyOnWriteArrayList 数组对象的实现就是使用了虚拟代理的方式，目的就是要让操作延迟，只有对象被真正用到的时候才会被克隆。

- **保护代理，适用于服务端对客户端的访问控制场景。**代理模式有一个非常重要的应用场景就是控制一个对象对另一个对象的访问与使用权限。当客户端通过代理对象访问服务端的原始对象时，代理对象会根据具体的规则来判断客户端是否有访问权限。比如，防火墙其实就是一种保护代理的具体实践。

- **远程代理，适用于需要本地执行远程服务代码的场景。** 在这种场景中，代理对象会隐藏处理所有与网络相关的复杂细节。随着微服务架构的流行，越来-越多的程序应用部署在多台服务器上，各自服务都更专注于各自的业务，当需要使用其他服务时就会频繁进行远程服务调用，但不可能所有的业务都要自己实现网络调用，于是就出现了的远程代理框架，比如，gRpc、Dubbo 等。

- **日志记录代理，适用于需要保存请求对象历史记录的场景**。比如，日志监控。客户端在调用请求时，并不会感知到日志记录，这是因为代理对象在原始对象周围添加了监控功能。

- **缓存代理，适用于缓存客户请求结果并对缓存生命周期进行管理的场景。**比如，商品详情页通常包含大量图片和文字介绍，代理对象可以对重复请求相同的结果进行缓存。



**优点：**

- 作为接口的特定中间层，能够降低对象间的直接耦合。代理对象很好地解耦了客户端与服务端之间的调用关系，即使客户端在使用服务端对象还未准备好或不存在时，代理也可以正常工作。

- 虚拟代理通过延迟加载以及使用小对象代表大对象的方式，帮助减少系统资源的损耗，提升系统运行速度。

- 保护代理可以控制客户端对服务端的访问权限。

- 远程代理帮助客户端快速访问分布式机器上的对象，分布式服务器通常可以提供集群负载均衡、故障容错和高性能的计算能力。

- 日志记录代理能记录每次操作的信息，对于用户使用轨迹跟踪、数据统计、定位问题等都有重要作用。

- 缓存代理能够提供各式各样的缓存结果，对于需要高频读取重复数据的系统来说，能极大地提升系统性能。

**缺点：**

- 因为在客户端和服务端之间增加了代理对象，所以也增加了系统的复杂度。

- 实现了代理模式的服务，如果处理请求的时间过长，就容易造成多个服务调用阻塞而影响整体系统的处理速度。

- 对于一些偏操作系统或标准协议等底层的代理服务而言，代码实现可能很复杂。



> Jdk 方法实现动态代理的原理：Jdk的动态代理实现方法是依赖于**接口**的，首先使用接口来定义好操作的规范。然后通过`Proxy`类产生的代理对象调用被代理对象的操作。
>
> cgLib：
>
> CGLIB原理：动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用java反射的JDK动态代理要快。
>
> CGLIB底层：使用字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。
>
> CGLIB缺点：对于final方法，无法进行代理。



### 3.15[❤] 结构型设计模式总结

- 适配器模式，实现了不同接口功能之间的转换，为组件的快速复用提供了直接的解决办法。

- 桥接模式，实现了抽象实体和抽象行为之间的永久绑定，可以理解为在基于已有的构件上设计可能会发生变化的行为。它往往与抽象工厂模式共同用于跨平台设计的场景。

- 组合模式，用于表达整体和部分的关系，可以忽略单个对象和合成对象之间的差别。它实际采用的是一种树状结构。

- 装饰模式，与继承不同，通过代理方式实现了接口功能的多态，避免了大量子类的派生。它适用于链状和树状的结构，但容易造成对象与装饰器之间耦合度过高。

- 门面模式，用于对子系统提供统一的接口。

- 享元模式，用于解决大对象重复创建损耗资源的问题，通过共享对象池来复用对象。

- 代理模式，模式的结构与装饰模式非常相似，但侧重点不同，一种是修改对象的行为，另一种是控制访问。

**这七种结构型模式重点关注的都是对象与对象之间的结构关系，以及如何更好地组合以扩展代码整体结构的灵活性。**



### 3.16  职责链模式

定义： 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止



![image-20220322171543783](X:\JavaNote\design-mode\image\image-20220322171543783.png)

职责链模式仅有两个角色：

**处理类（Handler）：**可以是一个接口，用于接收请求并将请求分派到处理程序链条中（实际上就是一个数组链表），其中，会先将链中的第一个处理程序放入开头来处理。

**具体处理类（HandlerA、B、C）：**按照链条顺序对请求进行具体处理。

**为什么使用职责链模式？**

**第一，解耦使用者和后台庞大的流程化处理。**我们都知道，在线购物订单里包含了物流、商品、支付、会员等多个系统的处理逻辑，如果让使用者一一和它们对接，势必会造成使用困难、系统之间调用混乱的情况发生，而通过订单建立一个订单的状态变更流程，就能将这些系统很好地串联在一起，这不仅能够让使用者只需要关注订单流程这一个入口，同时还能够让不同的系统按照各自的职责来发挥作用。比如，订单在未完成支付前，商品系统是不会通知物流系统进行商品发货的。

**第二，为了动态更换流程处理中的处理对象。**比如，在请假流程中，申请人一般会提交申请给直接领导审批，但有时直接领导可能无法进行审批操作，这时系统就可以更换审批人到其他审批人，这样就不会阻塞请假流程的审批。

**第三，为了处理一些需要递归遍历的对象列表。**比如，权限的规则过滤。对于不同部门不同级别人员的权限，就可以采用一个过滤链条来进行权限的管控。



优点：

**降低客户端对象与处理链条上对象之间的耦合度。**比如，提交上线审核，提交人只知道最开始申请的处理人是谁，而后续是否需要别的审核人其实是由处理链条来控制的。

**提升系统扩展性**。对于需要多次处理的同一个请求，可以在链条上增加新的具体处理类，满足开闭原则，能极大地提升系统扩展性。

**增强了具体处理类的职责独立性。**即便链条上的工作流程发生了变化，也可以动态地改变具体处理类的调用次序和增加类的新的职责。每个类只需要处理自己该处理的工作，不该处理的就传递给下一个对象完成，明确各类的责任范围，同时也符合类的单一职责原则。

**简化了对象之间前后关联处理的复杂性。**每个对象只需存储一个指向后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。

缺点：

**降低性能**。由于每一个请求都需要经历一次完整的链条上具体处理类的处理，系统性能势必会受到一定影响，比如，依赖更多的代码行或依赖更复杂的代码逻辑。

**调试难度增大**。调试代码需要验证每个具体处理者是否都能接收到请求，一旦出现错误，排查与修改也变得更加麻烦。

**容易出现死锁异常。**一旦某一个对象设置后继者出现错误，就会出现循环调用，进而导致堆栈溢出的错误。



### 3.17 访问者模式



**定义：**允许在运行时将一个或多个操作应用于一组对象，将**操作与对象结构**分离。

![img](X:\JavaNote\design-mode\image\Cgp9HWDLGGqAbqBvAADh3rnbUgQ166.png)

访问者模式包含的关键角色有四个：

**访问者类（Visitor）**：这是一个接口或抽象类，定义声明所有可访问类的访问操作。

**访问者实现类（VisitorBehavior）**：实现在访问者类中声明的所有访问方法。

**访问角色类（Element）**：定义一个可以获取访问操作的接口，这是使客户端对象能够“访问”的入口点。

**访问角色实现类（Element A 等）**：实现访问角色类接口的具体实现类，将访问者对象传递给此对象作为参数。

**什么叫分派？根据对象的类型而对方法进行的选择,就是分派(Dispatch)。**

发生在编译时的分派叫静态分派，例如重载（overload），发生在运行时的分派叫动态分派，例如重写（overwrite）。

单分派与多分派

- 单分派

依据单个宗量进行方法的选择就叫单分派，Java 动态分派只根据方法的接收者一个宗量进行分配，所以其是单分派

- 多分派

依据多个宗量进行方法的选择就叫多分派，Java 静态分派要根据方法的接收者与参数这两个宗量进行分配，所以其是多分派



**使用场景**

**当对象的数据结构相对稳定，而操作却经常变化的时候。** 比如，上面例子中路由器本身的内部构造（也就是数据结构）不会怎么变化，但是在不同操作系统下的操作可能会经常变化，比如，发送数据、接收数据等。

**需要将数据结构与不常用的操作进行分离的时候。** 比如，扫描文件内容这个动作通常不是文件常用的操作，但是对于文件夹和文件来说，和数据结构本身没有太大关系（树形结构的遍历操作），扫描是一个额外的动作，如果给每个文件都添加一个扫描操作会太过于重复，这时采用访问者模式是非常合适的，能够很好分离文件自身的遍历操作和外部的扫描操作。

**需要在运行时动态决定使用哪些对象和方法的时候。** 比如，对于监控系统来说，很多时候需要监控运行时的程序状态，但大多数时候又无法预知对象编译时的状态和参数，这时使用访问者模式就可以动态增加监控行为。



**优点：**



**简化客户端操作**。比如，扫描文件时，对于客户端来说只需要执行扫描，而不需要关心不同类型的文件该怎么读取，也不用知道文件该如何被读取。

**增加新的访问操作和访问者会非常便捷。**在每次新增操作时，都是将对象视为统一的访问者，只需要关注操作是否正确地在对象上执行，而不需要关注对象如何被构建，这样使操作变得更加容易。

**满足开闭原则。**由于访问者模式没有对原有对象进行修改，只是新增了外部的统一操作，扩展新类不影响旧类，满足开闭原则。

**满足单一职责原则。**每一个行为都是一个单一的行为操作，能够组合相关类的功能逻辑，到代码内聚度更高。

**通过行为能够快速组合一组复杂的对象结构。**比如，访问角色类可能是树形结构，增加一个新操作后，对每一个对象都是进行的统一操作，这时新增一个其他结构的对象也能按照统一操作进行，便能将多个不同结构的对象进行自由组合。



**缺点：**



**增加新的数据结构困难。**因为新增结构，又需要新增操作，这时就让结构和操作发生关联，也就破坏了原有的模式，并且可能造成原有结构的不可用。

**具体元素在变更时需要修改代码，容易引入问题。**虽然访问者模式分离了操作和对象，但是当访问者对象本身发生变化时，依然需要修改代码，这时可能会对操作的方法造成影响。



### 3.18 模板方法模式



**定义：**在操作中定义算法的框架，将一些步骤推迟到子类中。模板方法让子类在不改变算法结构的情况下重新定义算法的某些步骤。

![image-20220630153102519](X:\JavaNote\design-mode\image\image-20220630153102519.png)

**关键角色：**

- 抽象父类：定义一个算法所包含的所有步骤，并提供一些通用的方法逻辑
- 具体子类：继承自抽象父类，根据需要重写父类提供的算法步骤中的某些步骤



**为什么要使用模板方法模式：**

- 期望在一个通用的算法或流程框架下进行自定义开发。如使用 `Jenkins` 的持续集成发布系统中，可以定义一个固定的 `Jenkins Job` 任务将打包、发布、部署的流程作为一个通用的流程。
- 避免同样的代码逻辑进行重复编码。如调用 `HTTP` 接口时，会使用 `HttpClient、OkHttp` 等工具类进行二次开发，使用模板方法模式定义统一的 `HTTP` 接口的逻辑，能避免重复编码。



**使用场景：**

- 多个类有相同的方法并且逻辑可以共用时；

- 将通用的算法或固定流程设计为模板，在每一个具体的子类中再继续优化算法步骤或流程步骤时；

- 重构超长代码时，发现某一个经常使用的公有方法。



**优点：**

- 有效去除重复代码。 模板方法模式的父类保存通用的代码逻辑，这样可以让子类不再需要重复处理公用逻辑，只用关注特定的逻辑，从而起到去除子类中重复代码的目的。

- 有助于找到更通用的模板。 由于子类间重复的代码逻辑都会被抽取到父类中，父类也就慢慢变成了更通用的模板，这样有助于积累更多通用的模板，提升代码复用性和扩展性。



**缺点：**

- 不符合开闭原则。 一个父类调用子类实现操作，通过子类扩展增加新的行为，但是子类执行的结果便会受到父类的影响，不符合开闭原则的“对修改关闭”。

- 增加代码阅读的难度。 由于父类的某些步骤或方法被延迟到子类执行，那么需要跳转不同的子类阅读代码逻辑，如果子类的数量很多的话，跳转会很多，不方便联系上下文逻辑线索。而且模板方法中的步骤越多，其维护工作就可能会越困难。

- 违反里氏替换原则。 虽然模板方法模式中的父类会提供通用的实现方法，但是延迟到子类的操作便会变成某种定制化的操作，一旦替换子类，可能会导致父类不可用或整体逻辑发生变化。

> 里式替换原则（LSP）：所有引用基类（父类）的地方必须能透明地使用其子类的对象。



### 3.19 策略模式



策略模式常常用于替换过多的 `if-else` 嵌套判断



**定义：** 定义一系列算法，封装每个算法，并使他们可以互换策略让算法独立于使用它的客户端而变化。

![image-20220630174136497](X:\JavaNote\design-mode\image\image-20220630174136497.png)

**关键角色：**

- 上下文信息类（Context）：用于存放和执行需要使用的具体策略类以及客户端调用的逻辑。

- 抽象策略类（Strategy）：定义策略的共有方法。

- 具体策略类（StrategyA 等）：实现抽象策略类定义的共有方法。



**使用场景：**

- 系统中需要动态切换几种算法的场景。

- 使用多重的条件选择语句来实现的业务场景。

- 只希望客户端选择已经封装好的算法场景而不用关心算法实现细节。

- 分离使用策略和创建策略的场景。



为什么使用策略模式？

- **为了提升代码的可维护性。** 在实际开发中，有许多算法可以实现某一功能，如查找、排序等，通过 if-else 等条件判断语句来进行选择非常方便。但是这就会带来一个问题：当在这个算法类中封装了大量查找算法时，该类的代码就会变得非常复杂，维护也会突然就变得非常困难。虽然策略模式看上去比较笨重，但实际上在每一次新增策略时都通过新增类来进行隔离，短期虽然不如直接写 if-else 来得效率高，但长期来看，维护单一的简单类耗费的时间其实远远低于维护一个超大的复杂类。

- **为了动态快速地替换更多的算法。** 从上面的分析你会发现，策略模式最大的作用在于分离使用算法的逻辑和算法自身实现的逻辑，这样就意味着当我们想要优化算法自身的实现逻辑时就变得非常便捷，一方面可以采用最新的算法实现逻辑，另一方面可以直接弃用旧算法而采用新算法。使用策略模式能够很方便地进行替换。
- **为了应对需要频繁更换策略的场景。** 比如，用户推荐类场景。特别是对于一些 C 端产品来说，在获取了用户的反馈数据后，会根据用户的特性制定不同的运营策略，这时如果采用 if-else 的方式编码，那么每一次的策略变化都会导致系统代码的修改，从运营的角度看是不可接受的，而采用策略模式就能很容易地解决这个问题。



**优点：**

- 提供良好的代码扩展性。 每一个策略都是对应生成一个新的具体策略类，满足开闭原则，同时满足里氏替换原则，可以任意替换相同的策略，这样用户可以在不修改原有系统的基础上选择算法或行为，同时也可以灵活地增加新的算法或行为。

- 提供了一种管理多个不同算法策略的办法。 策略模式提供了一种很好的思路，可以将算法的实现和使用算法的代码隔离开来，这样就能很好地管理不同的算法。

- 提供使用组合替换继承的办法。 策略模式使用组合的方式来替代继承，避免了子类出现异常而影响父类。

- 能够降低使用多重条件（if-else）嵌套语句的理解难度。 在实际的开发中，使用 if-else 是非常常见的编程方法，但是随着业务逻辑变得越来越复杂，如果一味地增加 if-else，会让代码变得非常难以理解和维护，使用策略模式则能避免这些问题的出现。

- 在运行时动态切换算法，提升代码灵活性。 由于策略模式将算法的选择权交给了客户端，那么客户端可以根据自身的需求灵活地切换算法。



**缺点：**

- 客户端的学习成本变高。 虽然策略模式让客户端自行决定使用哪一个策略，看上去很自由，但实际上隐含着客户必须要知道所有的策略才能做选择的事实。一旦新增或修改策略，客户端都需要知道。
- 具体策略类的数量会剧增，增加维护成本。 由于每一个策略都对应一个具体策略类，所以当策略比较庞大时，需要维护的类数量也会激增。
- 不如函数式编程简洁。 现在有很多编程语言都支持函数式——允许在一组匿名函数中实现不同版本的算法。对于一些小型的策略来说，使用函数式编程就能解决问题，但使用策略模式反而过于复杂。



### 3.20 状态模式



定义：当一个对象内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。

![image-20220701232318433](X:\JavaNote\design-mode\image\image-20220701232318433.png)



**关键角色：**

- 状态接口 `(State)` ： 封装了状态行为
- 具体状态实现 `（Concrete State）` : 表示具体的状态
- 上下文信息类 `(Context)` : 引用了 `State` ，可以保持并切换各种状态。依赖于状态的各种操作委托给不同的状态对象执行。



**要点：**

- 必须要有一个Context类，这个类持有State接口，负责保持并切换当前的状态。
- 状态模式没有定义在哪里进行状态转换，本例是在Context类进行的，也有人在具体的State类中转换

**当使用Context类切换状态时**，状态类之间互相不认识，他们直接的依赖关系应该由客户端负责。
 例如，只有在接单状态的操作完成后才应该切换到出库状态，那么出库状态就对接单状态有了依赖，这个依赖顺序应该由客户端负责，而不是在状态内判断。

**当使用具体的State类切换时**，状态直接就可能互相认识，一个状态执行完就自动切换到了另一个状态去了



**优点：**

- 增强了程序的可扩展性，因为我们很容易添加一个State
- 增强了程序的封装性，每个状态的操作都被封装到了一个状态类中



缺点：

- 增加了大量的状态类



> - **策略模式**定义了一组可互相代替的算法，这一组算法对象完成的是同一个任务，只是使用的方式不同，例如同样是亿万富翁，马云通过卖东西实现，而王思聪通过继承实现。
> - **状态模式**不同的状态完成的任务完全不一样。



### 3.21 命令模式



**定义：** 将一个请求封装成一个对象，从而让用户使用不同的请求把客户端参数化；对请求排队或记录日志，以及支持可撤销的操作。



![image-20220702165020961](X:\JavaNote\design-mode\image\image-20220702165020961.png)



**关键角色：**

- 命令接口（Command）：定义命令
- 具体命令实现（ConcreteCommand）：具体执行的命令，实现 `Command` 接口
- 命令执行者（Receiver)：执行命令的角色，具体的命令引用他，让他完成命令的执行
- 调用命令(Invoker): 负责按照客户端的指令设置并执行命令，比如命令的撤销，日志记录等功能都需要在此类中完成



**使用场景：**

- 当需要将各种执行的动作抽象出来，使用时通过不同的参数来决定执行哪个对象
- 当某个或者某些操作需要支持撤销的场景
- 当要对操作过程记录日志，以便后期通过日志将操作过程重新做一遍时
- 当某个操作需要支持事务操作的时候



**要点：**

- `Command` 接口非常简单，通常只有一个`execute`方法，如果要支持撤销操作的话，再加一个`unexecute`方法
- 每个具体的命令类内部封装了实际执行命令的那个类（`Recevier`），或者那些类，以及执行需要的数据
- 每个具体命令类只完成一个请求，有多少个请求就有多少个命令
- `Invoker`类只认识接口`Command`，其他的都不认识
- 客户端类负责生成命令，并通过Invoker组装执行。



**优点**：

- 将调用操作与具体执行者解耦

你只管发出命令，至于命令由谁执行你不用关心。我们也可以随时将命令中具体执行者换掉，发出命令者是不知道的。例如你大老板交给经理一个任务，至于经理安排小张，还是小王来做，他根本就不关心

- 添加一个命令非常容易
- 很容易实现序列操作及实现回调系统

把命令加到一个列表中，迭代执行就可以实现序列操作了。 因为Java不能将函数作为参数，此处我们可以将命令对象当做参数，而这个对象还可执行，所以就实现了回调功能。



**缺点：**

类太多，每次增加一个命令，就要多加一个类。



### 3.22 迭代器模式



定义： 提供一种方法顺序访问一个容器对象中的各个元素，而又不需要暴露该对象的内部表示





1. **抽象迭代器**（Iterator）:抽象迭代器负责定义访问和遍历元素的接口
2. **具体迭代器**（MyListIterator）：提供具体的元素遍历行为
3. **抽象容器**（List）：负责定义提供具体迭代器的接口
4. **具体容器**（MyList）：创建具体迭代器



优点：

迭代器封装了具体的迭代算法，迭代算法的变化不会影响到集合对象的架构



缺点：

对于比较简单的遍历（如有序的集合），使用迭代器便利比较麻烦。除非有特点的数据结构，可能需要开发相应的迭代器



### 3.23 备忘录模式



定义： 在不破坏封闭的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以将对象恢复到原先保存的状态



备忘录模式有3个关键角色：

- Originator

是保存状态，恢复状态的目标对象。

- Memento

一个存储状态的类，里面没有业务逻辑，一般是一个POJO。

- CareTaker

负责保存和恢复 `Originator` 的状态，状态是保存在这类里面的





## 参考链接

[1]https://kaiwu.lagou.com/course/courseInfo.htm?courseId=710&sid=20-h5Url-0&buyFrom=2&pageId=1pz4#/content?courseId=710

[2]http://shusheng007.top/category/design-pattern/

